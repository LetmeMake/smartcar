2018/12/26
1.速度PID算法已移植成功，待后期调准
2.通过结构体指针的方式存放数据，使数据更清晰明了
3.蓝牙示波器调试成功
2018/12/27
1.MT9V032摄像头调试成功初步大小设为188*60，频率320，曝光1000
2.更改摄像头库程序，将图像数据地址分为两份，使单片机不断的获取数据
3.设固定阈值100，使图像转化为二值化图像
4.移入简单的大律法程序
2018/12/28
1.移植摄像头算法程序
2.增加角度PD
3.增加速度PI
2018/12/29
1.舵机控制算法移植成功，待调试
2.调试权重比系数，实现直道，大环道，顺利通行
2018/12/30
1.单边补线移植成功，效果不好，方向角有问题，容易打死，回不来。
2.如果之前PID程序已经调节完美，则尽量少改变值
3.现在主要改变，补线参数，权重比。
2018/12/31
1.丢线改：；中心等于上次的中心减去边沿的斜率
2.动态阈值算法：先由一副图像灰度  （最大值+最小值）/2 = 初步阈值
					再由初步阈值划分为前景和背景
					再由前景和背景分别 计算前景平均灰度和背景平均灰度
					得 阈值 = （前景平均灰度 + 背景平均灰度）/2
3.判断噪点，然后附近八点取平均
4.赛道元素判断：（通过判断元素，来改变速度目标值，和角度P）
				edge（x，y） = 中心线某点（x，y）- start（x，y）；//判断直道与弯道
				k = 中心线某点（x，y）与 start（x，y）的斜率； //判断赛道的弯曲程度，再通过edge（x，y）有几个极值点判断有几个弯
				直道 ： k = 0 ; edge = 0;
				在弯道内：k 为正负 ； edge 为 正负；
				出入弯道 ： k 恒为正（或 负）； edge 恒为 正（或 负）；
				大S	：	k有正负，并且edge的极值点有多个并且值较大
				小S ：  k有正负，并且edge的极值点有多个并且值较小，可做直线处理
5.路径优化：可以采用最小二乘法来，求一次函数作为优化路线			（相当于抛弃权重拟合偏差，用斜率来控制方向）
6.控制策略：小S下，减小角度P
			大S下，增加角度P
			速度控制采用增量PID
			角度控制采用位置PD控制
			D采用定值
			P采用二次函数拟合的曲线	：	Kp = 中线偏移值的平方 / 2 + 定值；
										中线偏移值 = 摄像头中值 与 拟合中线的偏差
			角度：
			设定最大打角，最小打角，最大斜率，最小斜率
			
			（最大打角 - 最小打角） / （最大斜率 - 最小斜率）*斜率 + 固定PWM		（认为不靠谱）
			（最大拟合偏差 - 最小拟合偏差）/	（最大斜率 - 最小斜率）*斜率  = 中线偏差值
			
			速度： 
			设定最大速度，最小速度
			
			速度 = （最大速度 - 最小速度）/edge最大值*edge极值 +最小速度；
（以上是一次性将看到的报告文档思路记录下来，方便以后编写程序）取10到20行进行
2018/12/31（猜想增量PI自动调节方式）
1.增量PI公式：PIDInc = (PID->Kp * PID->Ek) - (PID->Ki * PID->Ek1);			//仅保留PI计算			
			P增大可以增加系统的反应调节速度，I可以增加系统的快速稳定
			设定要求：系统的反应时间为：t ，系统的稳定时间为： T
			设系统到达第一次目标值的时间为 反应时间，系统达到目标值并且震荡幅度小于目标值的百分之五的时间为：稳定时间。
			改变目标值 -->	开定时器计时	-->	读dma计数并与目标值计算《当 差小于目标值的百分之5时，记录当前时间t1中》
			-->	不断保存读取的dma由大变小和由小变大的值并进行相减运算《当 有5次连续差小于百分之五，记录时间t2》
			-->	关闭定时器。
			-->	《如果震荡时间t2过长，《如果有两次运算，且上次也是增加I并且并没有改善，则在上次的基础上减小I》，增加I》
			-->	保存上一次时间与PID参数
			-->	《如果稳定时间已经达标，反应时间没达标，则适当增加P》-->循环直到满足 t1<t,t2<T.
2.斜入十字处理:
			采用从下至上的扫描方法：判断是左边线还是右边线，中间的中值重新计算，附扫描代码：
			//////////////////////以下区分出左右边缘///////////////////////////
    uint8 xnum=num-1;
    uint8 bian_num=0;                                    //记录有效左右边缘点数
    for (int i=0;i<=xnum;i++)
    {
        uint8 x=bian[0][i];                                    //将该像素点的x坐标赋值给x
        uint8 y=bian[1][i];                                    //将像素点的y坐标赋值给y
        //以下为从左往右扫描 扫到第一个左边  要记住
        uint8 xy1=img[x][y+1];
        uint8 x1y=img[x+1][y];
        uint8 xy_1=img[x][y-1];
        uint8 x_1y=img[x-1][y];
        if (xy1==255&&x1y==255&&xy_1==0&&x_1y==0)
        {
            bianyuan[0][bian_num]=x;
            bianyuan[1][bian_num]=y;
            bianyuan[2][bian_num]=1;                                    //第三项为1 认为是左边界
            bian_num=bian_num+1;
        }
        else if (xy1==0&&x1y==255&&xy_1==255&&x_1y==0)
        {
            bianyuan[0][bian_num]=x;
            bianyuan[1][bian_num]=y;
            bianyuan[2][bian_num]=2;                                    //第三项为2 认为是右边界
            bian_num=bian_num+1;
        }
    }

				
				
				













